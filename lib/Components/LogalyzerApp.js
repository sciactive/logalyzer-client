(function (global, factory) {
	if (typeof define === "function" && define.amd) {
		define(['exports', 'QueryEditor', 'Nymph'], factory);
	} else if (typeof exports !== "undefined") {
		factory(exports, require('QueryEditor'), require('Nymph'));
	} else {
		var mod = {
			exports: {}
		};
		factory(mod.exports, global.QueryEditor, global.Nymph);
		global.LogalyzerApp = mod.exports;
	}
})(this, function (exports, _QueryEditor, _Nymph) {
	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _QueryEditor2 = _interopRequireDefault(_QueryEditor);

	var _Nymph2 = _interopRequireDefault(_Nymph);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : {
			default: obj
		};
	}

	/* src/Components/LogalyzerApp.html generated by Svelte v1.51.1 */
	const chartColors = {
		red: 'rgb(229,57,53)',
		indigo: 'rgb(57,73,171)',
		teal: 'rgb(0,137,123)',
		yellow: 'rgb(253,216,53)',
		pink: 'rgb(216,27,96)',
		blue: 'rgb(30,136,229)',
		green: 'rgb(67,160,71)',
		amber: 'rgb(255,179,0)',
		purple: 'rgb(142,36,170)',
		lightBlue: 'rgb(3,155,229)',
		lightGreen: 'rgb(124,179,66)',
		orange: 'rgb(251,140,0)',
		deepPurple: 'rgb(94,53,177)',
		cyan: 'rgb(0,172,193)',
		lime: 'rgb(192,202,51)',
		deepOrange: 'rgb(244,81,30)',
		brown: 'rgb(109,76,65)',
		grey: 'rgb(117,117,117)',
		blueGrey: 'rgb(84,110,122)'
	};

	///////////////////////////////////////
	//  Charting Functions
	///////////////////////////////////////

	const chartJsTimeSeries = function chartJsTimeSeries(graphType, area, stepped) {
		return function (app, label, axisLabel, data, elems, eventHandlers) {
			const timeFormat = 'YYYY-MM-DD HH:mm:ss';

			const color = Chart.helpers.color;
			const config = {
				type: graphType,
				data: {
					labels: [],
					datasets: [{
						label: axisLabel,
						backgroundColor: color(chartColors.indigo).alpha(0.5).rgbString(),
						borderColor: chartColors.indigo,
						fill: !!area,
						steppedLine: !!stepped,
						lineTension: 0,
						// cubicInterpolationMode: 'monotone',
						data: data.map(v => ({ x: v.label, y: v.value }))
					}]
				},
				options: {
					title: {
						display: true,
						text: label
					},
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						xAxes: [{
							type: "time",
							time: {
								format: timeFormat,
								// round: 'day'
								tooltipFormat: 'll HH:mm'
							},
							scaleLabel: {
								display: true,
								labelString: 'Date / Time'
							}
						}],
						yAxes: [{
							scaleLabel: {
								display: true,
								labelString: axisLabel
							}
						}]
					},
					onClick: function onClick(ev, elements) {
						if (elements[0] !== undefined && elements[0]._model !== undefined && elements[0]._model.label !== undefined && eventHandlers !== undefined && eventHandlers.hasOwnProperty(elements[0]._model.label)) {
							eventHandlers[elements[0]._model.label](app);
						}
					}
				}
			};

			const ctx = elems.canvas.getContext("2d");
			return { context: ctx, chart: new Chart(ctx, config) };
		};
	};

	const c3TimeSeries = function c3TimeSeries(graphType, area, stepped) {
		return function (app, label, axisLabel, data, elems, eventHandlers) {
			const config = {
				bindto: elems.svg,
				data: {
					x: 'x',
					xFormat: '%Y-%m-%d %H:%M:%S',
					type: graphType === 'line' ? area ? stepped ? 'area-step' : 'area' : stepped ? 'step' : 'line' : graphType,
					columns: [['x', ...data.map(v => v.label)], [axisLabel, ...data.map(v => v.value)]]
				},
				line: {
					step: {
						type: 'step-after'
					}
				},
				axis: {
					x: {
						type: 'timeseries',
						localtime: true,
						tick: {
							fit: true,
							format: '%e %b %y %H:%M:%S',
							rotate: -60,
							multiline: false
						},
						height: 100
					}
				},
				size: {
					height: app.get('chartHeight')
				},
				zoom: {
					enabled: true
				},
				subchart: {
					show: true
				}
			};

			elems.titlesvg.innerText = label;

			return { svg: c3.generate(config) };
		};
	};

	const c3CategoryChart = function c3CategoryChart(graphType, rotated) {
		return function (app, label, axisLabel, data, elems, eventHandlers) {
			const config = {
				bindto: elems.svg,
				data: {
					type: graphType,
					json: data.map(v => {
						v[axisLabel] = v.value;return v;
					}),
					keys: {
						x: 'label',
						value: [axisLabel]
					},
					onclick: function onclick(d, element) {
						if (d.name !== undefined && eventHandlers !== undefined && eventHandlers.hasOwnProperty(d.name)) {
							eventHandlers[d.name](app);
						}
					}
				},
				axis: {
					x: {
						type: 'category'
					},
					rotated: rotated
				},
				size: {
					height: app.get('chartHeight')
				},
				zoom: {
					enabled: true
				}
			};

			elems.titlesvg.innerText = label + " (" + data.length + " total)";

			return { svg: c3.generate(config) };
		};
	};

	const c3Chart = function c3Chart(graphType, rotated) {
		return function (app, label, axisLabel, data, elems, eventHandlers) {
			const config = {
				bindto: elems.svg,
				data: {
					type: graphType,
					columns: data.map(v => [v.label, v.value]),
					onclick: function onclick(d, element) {
						if (d.name !== undefined && eventHandlers !== undefined && eventHandlers.hasOwnProperty(d.name)) {
							eventHandlers[d.name](app);
						}
					}
				},
				bar: {
					width: {
						ratio: 1
					}
				},
				axis: {
					y: {
						label: {
							text: axisLabel,
							position: 'outer-middle'
						}
					},
					rotated: rotated
				},
				size: {
					height: app.get('chartHeight')
				},
				zoom: {
					enabled: true
				}
			};

			elems.titlesvg.innerText = label + " (" + data.length + " total)";

			return { svg: c3.generate(config) };
		};
	};

	const chartFunctions = {
		timeSeriesSteppedArea: {
			name: "Time Series Stepped Area, Chart.js",
			func: chartJsTimeSeries("line", true, true)
		},

		timeSeriesSteppedAreaC3: {
			name: "Time Series Stepped Area, C3.js",
			func: c3TimeSeries("line", true, true)
		},

		timeSeriesStepped: {
			name: "Time Series Stepped, Chart.js",
			func: chartJsTimeSeries("line", false, true)
		},

		timeSeriesSteppedC3: {
			name: "Time Series Stepped, C3.js",
			func: c3TimeSeries("line", false, true)
		},

		timeSeriesLine: {
			name: "Time Series Line, Chart.js",
			func: chartJsTimeSeries("line")
		},

		timeSeriesLineC3: {
			name: "Time Series Line, C3.js",
			func: c3TimeSeries("line")
		},

		timeSeriesArea: {
			name: "Time Series Area, Chart.js",
			func: chartJsTimeSeries("line", true)
		},

		timeSeriesAreaC3: {
			name: "Time Series Area, C3.js",
			func: c3TimeSeries("line", true)
		},

		timeSeriesBar: {
			name: "Time Series Bar, Chart.js",
			func: chartJsTimeSeries("bar")
		},

		timeSeriesBarC3: {
			name: "Time Series Bar, C3.js",
			func: c3TimeSeries("bar")
		},

		bar: {
			name: "Bar Chart, Chart.js",
			func: function func(app, label, axisLabel, data, elems, eventHandlers) {
				const color = Chart.helpers.color;
				const config = {
					type: 'bar',
					data: {
						labels: data.map(v => v.label),
						datasets: [{
							label: axisLabel,
							backgroundColor: color(chartColors.blue).alpha(0.5).rgbString(),
							borderColor: chartColors.blueGrey,
							borderWidth: 1,
							data: data.map(v => v.value)
						}]
					},
					options: {
						// Elements options apply to all of the options unless overridden in a dataset
						// In this case, we are setting the border of each horizontal bar to be 2px wide
						elements: {
							rectangle: {
								borderWidth: 2
							}
						},
						responsive: true,
						maintainAspectRatio: false,
						legend: {
							display: false
						},
						title: {
							display: true,
							text: label + " (" + data.length + " total)"
						},
						onClick: function onClick(ev, elements) {
							if (elements[0] !== undefined && elements[0]._model !== undefined && elements[0]._model.label !== undefined && eventHandlers !== undefined && eventHandlers.hasOwnProperty(elements[0]._model.label)) {
								eventHandlers[elements[0]._model.label](app);
							}
						}
					}
				};

				const ctx = elems.canvas.getContext("2d");
				return { context: ctx, chart: new Chart(ctx, config) };
			}
		},

		categoryBarC3: {
			name: "Bar Chart - Category, C3.js",
			func: c3CategoryChart('bar')
		},

		barC3: {
			name: "Bar Chart, C3.js",
			func: c3Chart('bar')
		},

		horizontalBar: {
			name: "Horizontal Bar Chart, Chart.js",
			func: function func(app, label, axisLabel, data, elems, eventHandlers) {
				const color = Chart.helpers.color;
				const config = {
					type: 'horizontalBar',
					data: {
						labels: data.map(v => v.label),
						datasets: [{
							label: axisLabel,
							backgroundColor: color(chartColors.blue).alpha(0.5).rgbString(),
							borderColor: chartColors.blueGrey,
							borderWidth: 1,
							data: data.map(v => v.value)
						}]
					},
					options: {
						// Elements options apply to all of the options unless overridden in a dataset
						// In this case, we are setting the border of each horizontal bar to be 2px wide
						elements: {
							rectangle: {
								borderWidth: 2
							}
						},
						responsive: true,
						maintainAspectRatio: false,
						legend: {
							display: false
						},
						title: {
							display: true,
							text: label + " (" + data.length + " total)"
						},
						onClick: function onClick(ev, elements) {
							if (elements[0] !== undefined && elements[0]._model !== undefined && elements[0]._model.label !== undefined && eventHandlers !== undefined && eventHandlers.hasOwnProperty(elements[0]._model.label)) {
								eventHandlers[elements[0]._model.label](app);
							}
						}
					}
				};

				const ctx = elems.canvas.getContext("2d");
				return { context: ctx, chart: new Chart(ctx, config) };
			}
		},

		categoryHorizontalBarC3: {
			name: "Horizontal Bar Chart - Category, C3.js",
			func: c3CategoryChart('bar', true)
		},

		horizontalBarC3: {
			name: "Horizontal Bar Chart, C3.js",
			func: c3Chart('bar', true)
		},

		pie: {
			name: "Pie Chart, Chart.js",
			func: function func(app, label, axisLabel, data, elems, eventHandlers) {
				const color = Chart.helpers.color;
				const chartColorsKeys = Object.keys(chartColors);
				const config = {
					type: 'pie',
					data: {
						labels: data.map(v => v.label),
						datasets: [{
							label: axisLabel,
							backgroundColor: data.map((v, i) => color(chartColors[chartColorsKeys[i % chartColorsKeys.length]]).alpha(0.5).rgbString()),
							data: data.map(v => v.value)
						}]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						title: {
							display: true,
							text: label + " (" + data.length + " total)"
						},
						onClick: function onClick(ev, elements) {
							if (elements[0] !== undefined && elements[0]._index !== undefined && data[elements[0]._index] !== undefined && eventHandlers !== undefined && eventHandlers.hasOwnProperty(data[elements[0]._index].label)) {
								eventHandlers[data[elements[0]._index].label](app);
							}
						}
					}
				};

				const ctx = elems.canvas.getContext("2d");
				return { context: ctx, chart: new Chart(ctx, config) };
			}
		},

		pieC3: {
			name: "Pie Chart, C3.js",
			func: c3Chart('pie')
		},

		rawDataColonSeparated: {
			name: "Raw Data (No Chart), Colon Separated",
			func: function func(app, label, axisLabel, data, elems, eventHandlers) {
				const sanitizer = document.createElement("span");
				const sanitizeText = text => {
					sanitizer.innerText = text;
					return sanitizer.innerHTML;
				};
				elems.titleraw.innerText = label + " (" + data.length + " total)";
				elems.raw.innerHTML = data.map(v => "<var>" + sanitizeText(v.label) + "</var>: " + sanitizeText(v.value)).join("\n");
				return { raw: elems.raw };
			}
		},

		rawDataColumns: {
			name: "Raw Data (No Chart), Columns",
			func: function func(app, label, axisLabel, data, elems, eventHandlers) {
				const sanitizer = document.createElement("span");
				const sanitizeText = text => {
					sanitizer.innerText = text;
					return sanitizer.innerHTML;
				};
				const maxWidth = data.reduce((currentMaxWidth, currentElem) => currentElem.label.length > currentMaxWidth ? currentElem.label.length : currentMaxWidth, 0);
				elems.titleraw.innerText = label + " (" + data.length + " total)";
				elems.raw.innerHTML = data.map(v => sanitizeText(v.label) + Array(maxWidth - v.label.length + 1).join(" ") + " " + sanitizeText(v.value)).join("\n");
				return { raw: elems.raw };
			}
		},

		rawDataEntries: {
			name: "Raw Data (No Chart), Entries Only",
			func: function func(app, label, axisLabel, data, elems, eventHandlers) {
				const sanitizer = document.createElement("span");
				const sanitizeText = text => {
					sanitizer.innerText = text;
					return sanitizer.innerHTML;
				};
				elems.titleraw.innerText = label + " (" + data.length + " total)";
				elems.raw.innerHTML = data.map(v => sanitizeText(v.label)).join("\n");
				return { raw: elems.raw };
			}
		}
	};

	const originalHash = window.location.hash.replace(/^#/, "");
	let currentHash = originalHash;

	function __aggregateFunctions(options) {
		return _Nymph2.default.getEntityClass(options.class).aggregateFunctions;
	}

	function __aggregateFunctionsKeys(options) {
		return Object.keys(_Nymph2.default.getEntityClass(options.class).aggregateFunctions);
	}

	function query(options, selectors) {
		return [options, ...selectors];
	}

	function urlHashUpdate(aggregateFunction, chartFunction, options, selectors, sort, chartHeight) {
		currentHash = JSON.stringify({ aggregateFunction, chartFunction, options, selectors, sort, chartHeight });
		window.location.hash = currentHash;
		return null;
	}

	function data() {
		return {
			__showQueryEditor: false,
			__loading: false,
			__currentChart: null,
			__chartFunctions: chartFunctions,
			__chartFunctionsKeys: Object.keys(chartFunctions),
			supportedClasses: [],
			chartHeight: 700,
			aggregateFunction: "rawLogLine",
			chartFunction: "rawDataEntries",
			sort: "unchanged",
			options: {},
			selectors: []
		};
	};

	var methods = {
		runQuery() {
			const __currentChart = this.get("__currentChart");
			const aggregateFunction = this.get("aggregateFunction");
			const chartFunction = this.get("chartFunction");

			if (__currentChart && __currentChart.chart) {
				__currentChart.chart.destroy();
			}
			if (__currentChart && __currentChart.context) {
				__currentChart.context.clearRect(0, 0, this.refs.chartcanvas.width, this.refs.chartcanvas.height);
			}
			if (__currentChart && __currentChart.raw) {
				__currentChart.raw.innerHTML = "";
			}

			this.set({
				__currentChart: null,
				__loading: true
			});
			const query = this.get("query");
			_Nymph2.default.getEntities(...query).then(entries => {
				const aggFuncObj = this.get("__aggregateFunctions")[aggregateFunction];
				const sort = this.get("sort");
				const chartFuncObj = chartFunctions[chartFunction];
				// Run the aggregator:
				const aggResults = aggFuncObj.func(entries, sort);
				const data = aggResults.data;
				const eventHandlers = aggResults.eventHandlers;

				// Create the chart:
				this.set({
					__currentChart: chartFuncObj.func(this, aggFuncObj.name, aggFuncObj.axisLabel, data, {
						canvas: this.refs.chartcanvas,
						titlesvg: this.refs.titlesvg,
						svg: this.refs.chartsvg,
						titleraw: this.refs.titleraw,
						raw: this.refs.chartraw
					}, eventHandlers),
					__loading: false
				});
			}, err => {
				alert("Error: " + err);
			});
		},

		toggleQueryEditor() {
			this.set({ __showQueryEditor: !this.get("__showQueryEditor") });
		}
	};

	function oncreate() {
		const updateFromHash = hash => {
			try {
				const state = JSON.parse(hash);
				this.set({ selectors: [] });
				this.set(state);
			} catch (e) {
				// ignore errors here.
			}
		};
		updateFromHash(originalHash);
		setInterval(() => {
			// Compare the current hash with the window's hash. If the window's
			// hash has been updated, update our state.
			const windowHash = window.location.hash.replace(/^#/, '');
			if (windowHash !== currentHash) {
				currentHash = windowHash;
				updateFromHash(currentHash);
			}
		}, 5);

		this.observe("options", () => {
			const __aggregateFunctions = this.get("__aggregateFunctions");
			const aggregateFunction = this.get("aggregateFunction");
			if (!__aggregateFunctions.hasOwnProperty(aggregateFunction)) {
				const __aggregateFunctionsKeys = this.get("__aggregateFunctionsKeys");
				this.set({ aggregateFunction: __aggregateFunctionsKeys[0] });
			}
		});

		this.observe("aggregateFunction", value => {
			const sort = this.get("sort");
			const aggregate = this.get("__aggregateFunctions")[value];
			if (aggregate.sorting.indexOf(sort) === -1) {
				this.set({ sort: aggregate.sorting[0] });
			}
		});
	};

	function encapsulateStyles(node) {
		setAttribute(node, "svelte-3106213277", "");
	}

	function add_css() {
		var style = createElement("style");
		style.id = 'svelte-3106213277-style';
		style.textContent = "[svelte-3106213277].w-auto,[svelte-3106213277] .w-auto{width:auto}[svelte-3106213277].query-editor h2,[svelte-3106213277] .query-editor h2{border-bottom:1px solid #000;padding-bottom:.5em;margin-bottom:.5em}[svelte-3106213277].chart-container > .hidden,[svelte-3106213277] .chart-container > .hidden{display:none}[svelte-3106213277].chart-canvas,[svelte-3106213277] .chart-canvas{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}[svelte-3106213277].loader,[svelte-3106213277] .loader,[svelte-3106213277].loader:after,[svelte-3106213277] .loader:after{border-radius:50%;width:3em;height:3em}[svelte-3106213277].loader,[svelte-3106213277] .loader{margin:60px auto;font-size:10px;position:relative;text-indent:-9999em;border-top:1.1em solid rgba(0,0,0, 0.2);border-right:1.1em solid rgba(0,0,0, 0.2);border-bottom:1.1em solid rgba(0,0,0, 0.2);border-left:1.1em solid #000000;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);-webkit-animation:load8 1.1s infinite linear;animation:svelte-3106213277-load8 1.1s infinite linear}@-webkit-keyframes load8 {[svelte-3106213277]0%,[svelte-3106213277] 0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}[svelte-3106213277]100%,[svelte-3106213277] 100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes svelte-3106213277-load8{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}";
		appendNode(style, document.head);
	}

	function create_main_fragment(state, component) {
		var div,
		    div_1,
		    button,
		    text,
		    text_1,
		    label,
		    text_2,
		    select,
		    select_updating = false,
		    text_4,
		    label_1,
		    text_5,
		    select_1,
		    select_1_updating = false,
		    text_7,
		    label_2,
		    text_8,
		    select_2,
		    select_2_updating = false,
		    text_10,
		    div_2,
		    text_11,
		    button_1,
		    text_13,
		    button_2,
		    text_15,
		    button_3,
		    text_19,
		    div_3,
		    queryeditor_updating = {},
		    div_3_class_value,
		    text_21,
		    hr,
		    text_22,
		    div_4,
		    div_5,
		    div_5_class_value,
		    text_23,
		    div_6,
		    div_7,
		    div_8,
		    text_24,
		    div_9,
		    pre,
		    div_7_class_value,
		    text_27,
		    div_10,
		    h5,
		    text_28,
		    div_11,
		    div_10_class_value,
		    text_30,
		    canvas,
		    canvas_class_value;

		var current_block_type = select_block_type(state);
		var if_block = current_block_type(state, component);

		function click_handler(event) {
			component.toggleQueryEditor();
		}

		var __aggregateFunctionsKeys_1 = state.__aggregateFunctionsKeys;

		var each_blocks = [];

		for (var i = 0; i < __aggregateFunctionsKeys_1.length; i += 1) {
			each_blocks[i] = create_each_block(state, __aggregateFunctionsKeys_1, __aggregateFunctionsKeys_1[i], i, component);
		}

		function select_change_handler() {
			select_updating = true;
			component.set({ aggregateFunction: selectValue(select) });
			select_updating = false;
		}

		function change_handler(event) {
			var state = component.get();
			component.set({ chartFunction: state.__aggregateFunctions[state.aggregateFunction].defaultChartFunction });
		}

		var __chartFunctionsKeys = state.__chartFunctionsKeys;

		var each_1_blocks = [];

		for (var i = 0; i < __chartFunctionsKeys.length; i += 1) {
			each_1_blocks[i] = create_each_block_1(state, __chartFunctionsKeys, __chartFunctionsKeys[i], i, component);
		}

		function select_1_change_handler() {
			select_1_updating = true;
			component.set({ chartFunction: selectValue(select_1) });
			select_1_updating = false;
		}

		var sorting = state.__aggregateFunctions[state.aggregateFunction].sorting;

		var each_2_blocks = [];

		for (var i = 0; i < sorting.length; i += 1) {
			each_2_blocks[i] = create_each_block_2(state, sorting, sorting[i], i, component);
		}

		function select_2_change_handler() {
			select_2_updating = true;
			component.set({ sort: selectValue(select_2) });
			select_2_updating = false;
		}

		function click_handler_1(event) {
			var state = component.get();
			component.set({ chartHeight: state.chartHeight + 40 });
		}

		function click_handler_2(event) {
			var state = component.get();
			component.set({ chartHeight: state.chartHeight - 40 });
		}

		function click_handler_3(event) {
			component.runQuery();
		}

		var queryeditor_initial_data = {
			classCheckbox: "mr-1",
			classInput: "form-control form-control-sm d-inline w-auto",
			classSelect: "form-control form-control-sm d-inline w-auto",
			classAddButton: "btn btn-sm btn-primary mx-1",
			classRemoveButton: "btn btn-sm btn-danger mx-1",
			classButton: "btn btn-sm btn-secondary mx-1"
		};
		if ('options' in state) {
			queryeditor_initial_data.options = state.options;
			queryeditor_updating.options = true;
		}
		if ('selectors' in state) {
			queryeditor_initial_data.selectors = state.selectors;
			queryeditor_updating.selectors = true;
		}
		if ('supportedClasses' in state) {
			queryeditor_initial_data.supportedClasses = state.supportedClasses;
			queryeditor_updating.supportedClasses = true;
		}
		var queryeditor = new _QueryEditor2.default({
			root: component.root,
			data: queryeditor_initial_data,
			_bind: function _bind(changed, childState) {
				var state = component.get(),
				    newState = {};
				if (!queryeditor_updating.options && changed.options) {
					newState.options = childState.options;
				}

				if (!queryeditor_updating.selectors && changed.selectors) {
					newState.selectors = childState.selectors;
				}

				if (!queryeditor_updating.supportedClasses && changed.supportedClasses) {
					newState.supportedClasses = childState.supportedClasses;
				}
				queryeditor_updating = assign({}, changed);
				component._set(newState);
				queryeditor_updating = {};
			}
		});

		component.root._beforecreate.push(function () {
			var state = component.get(),
			    childState = queryeditor.get(),
			    newState = {};
			if (!childState) return;
			if (!queryeditor_updating.options) {
				newState.options = childState.options;
			}

			if (!queryeditor_updating.selectors) {
				newState.selectors = childState.selectors;
			}

			if (!queryeditor_updating.supportedClasses) {
				newState.supportedClasses = childState.supportedClasses;
			}
			queryeditor_updating = { options: true, selectors: true, supportedClasses: true };
			component._set(newState);
			queryeditor_updating = {};
		});

		var queryeditor_context = {
			state: state
		};

		return {
			c: function create() {
				div = createElement("div");
				div_1 = createElement("div");
				button = createElement("button");
				if_block.c();
				text = createText(" Query Editor");
				text_1 = createText("\n    ");
				label = createElement("label");
				text_2 = createText("Aggreg.\n      ");
				select = createElement("select");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_4 = createText("\n    ");
				label_1 = createElement("label");
				text_5 = createText("Chart\n      ");
				select_1 = createElement("select");

				for (var i = 0; i < each_1_blocks.length; i += 1) {
					each_1_blocks[i].c();
				}

				text_7 = createText("\n    ");
				label_2 = createElement("label");
				text_8 = createText("Sort\n      ");
				select_2 = createElement("select");

				for (var i = 0; i < each_2_blocks.length; i += 1) {
					each_2_blocks[i].c();
				}

				text_10 = createText("\n    ");
				div_2 = createElement("div");
				text_11 = createText("Height\n      ");
				button_1 = createElement("button");
				button_1.textContent = "+";
				text_13 = createText("\n      ");
				button_2 = createElement("button");
				button_2.textContent = "-";
				text_15 = createText("\n      ");
				button_3 = createElement("button");
				button_3.textContent = "Run";
				text_19 = createText("\n  ");
				div_3 = createElement("div");
				queryeditor._fragment.c();
				text_21 = createText("\n  ");
				hr = createElement("hr");
				text_22 = createText("\n  ");
				div_4 = createElement("div");
				div_5 = createElement("div");
				text_23 = createText("\n    ");
				div_6 = createElement("div");
				div_7 = createElement("div");
				div_8 = createElement("div");
				text_24 = createText("\n          ");
				div_9 = createElement("div");
				pre = createElement("pre");
				text_27 = createText("\n        ");
				div_10 = createElement("div");
				h5 = createElement("h5");
				text_28 = createText("\n          ");
				div_11 = createElement("div");
				text_30 = createText("\n      ");
				canvas = createElement("canvas");
				this.h();
			},

			h: function hydrate() {
				encapsulateStyles(div);
				button.type = "button";
				button.className = "btn btn-secondary";
				addListener(button, "click", click_handler);
				addListener(select, "change", select_change_handler);
				if (!('aggregateFunction' in state)) component.root._beforecreate.push(select_change_handler);
				select.className = "form-control d-inline w-auto ml-2";
				addListener(select, "change", change_handler);
				label.className = "mx-2 mb-0";
				addListener(select_1, "change", select_1_change_handler);
				if (!('chartFunction' in state)) component.root._beforecreate.push(select_1_change_handler);
				select_1.className = "form-control d-inline w-auto ml-2";
				label_1.className = "mx-2 mb-0";
				addListener(select_2, "change", select_2_change_handler);
				if (!('sort' in state)) component.root._beforecreate.push(select_2_change_handler);
				select_2.className = "form-control d-inline w-auto ml-2";
				label_2.className = "mx-2 mb-0";
				button_1.type = "button";
				button_1.className = "btn btn-secondary";
				addListener(button_1, "click", click_handler_1);
				button_2.type = "button";
				button_2.className = "btn btn-secondary";
				addListener(button_2, "click", click_handler_2);
				button_3.type = "button";
				button_3.className = "btn btn-primary";
				addListener(button_3, "click", click_handler_3);
				div_2.className = "display-inline-block ml-auto";
				div_1.className = "d-flex";
				div_3.className = div_3_class_value = "mb-3 " + (state.__showQueryEditor ? '' : 'd-none');
				div_5.className = div_5_class_value = "loader " + (state.__loading ? '' : 'd-none');
				div_8.className = "card-header";
				pre.className = "raw-elem";
				div_9.className = "card-body";
				div_7.className = div_7_class_value = state.__currentChart && state.__currentChart.raw ? 'card' : 'hidden';
				h5.className = "text-center";
				div_10.className = div_10_class_value = state.__currentChart && state.__currentChart.svg ? 'chart-svg' : 'hidden';
				canvas.className = canvas_class_value = state.__currentChart && state.__currentChart.chart ? 'chart-canvas' : 'hidden';
				div_6.className = "chart-container";
				setStyle(div_6, "position", "relative");
				setStyle(div_6, "height", "" + state.chartHeight + "px");
				setStyle(div_6, "width", "100%");
				setStyle(div_4, "position", "relative");
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(div_1, div);
				appendNode(button, div_1);
				if_block.m(button, null);
				appendNode(text, button);
				appendNode(text_1, div_1);
				appendNode(label, div_1);
				appendNode(text_2, label);
				appendNode(select, label);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(select, null);
				}

				selectOption(select, state.aggregateFunction);

				appendNode(text_4, div_1);
				appendNode(label_1, div_1);
				appendNode(text_5, label_1);
				appendNode(select_1, label_1);

				for (var i = 0; i < each_1_blocks.length; i += 1) {
					each_1_blocks[i].m(select_1, null);
				}

				selectOption(select_1, state.chartFunction);

				appendNode(text_7, div_1);
				appendNode(label_2, div_1);
				appendNode(text_8, label_2);
				appendNode(select_2, label_2);

				for (var i = 0; i < each_2_blocks.length; i += 1) {
					each_2_blocks[i].m(select_2, null);
				}

				selectOption(select_2, state.sort);

				appendNode(text_10, div_1);
				appendNode(div_2, div_1);
				appendNode(text_11, div_2);
				appendNode(button_1, div_2);
				appendNode(text_13, div_2);
				appendNode(button_2, div_2);
				appendNode(text_15, div_2);
				appendNode(button_3, div_2);
				appendNode(text_19, div);
				appendNode(div_3, div);
				queryeditor._mount(div_3, null);
				appendNode(text_21, div);
				appendNode(hr, div);
				appendNode(text_22, div);
				appendNode(div_4, div);
				appendNode(div_5, div_4);
				appendNode(text_23, div_4);
				appendNode(div_6, div_4);
				appendNode(div_7, div_6);
				appendNode(div_8, div_7);
				component.refs.titleraw = div_8;
				appendNode(text_24, div_7);
				appendNode(div_9, div_7);
				appendNode(pre, div_9);
				component.refs.chartraw = pre;
				appendNode(text_27, div_6);
				appendNode(div_10, div_6);
				appendNode(h5, div_10);
				component.refs.titlesvg = h5;
				appendNode(text_28, div_10);
				appendNode(div_11, div_10);
				component.refs.chartsvg = div_11;
				appendNode(text_30, div_6);
				appendNode(canvas, div_6);
				component.refs.chartcanvas = canvas;
				component.refs.canvascontainer = div_6;
			},

			p: function update(changed, state) {
				if (current_block_type !== (current_block_type = select_block_type(state))) {
					if_block.u();
					if_block.d();
					if_block = current_block_type(state, component);
					if_block.c();
					if_block.m(button, text);
				}

				var __aggregateFunctionsKeys_1 = state.__aggregateFunctionsKeys;

				if (changed.__aggregateFunctionsKeys || changed.__aggregateFunctions) {
					for (var i = 0; i < __aggregateFunctionsKeys_1.length; i += 1) {
						if (each_blocks[i]) {
							each_blocks[i].p(changed, state, __aggregateFunctionsKeys_1, __aggregateFunctionsKeys_1[i], i);
						} else {
							each_blocks[i] = create_each_block(state, __aggregateFunctionsKeys_1, __aggregateFunctionsKeys_1[i], i, component);
							each_blocks[i].c();
							each_blocks[i].m(select, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].u();
						each_blocks[i].d();
					}
					each_blocks.length = __aggregateFunctionsKeys_1.length;
				}

				if (!select_updating) selectOption(select, state.aggregateFunction);

				var __chartFunctionsKeys = state.__chartFunctionsKeys;

				if (changed.__chartFunctionsKeys || changed.__chartFunctions) {
					for (var i = 0; i < __chartFunctionsKeys.length; i += 1) {
						if (each_1_blocks[i]) {
							each_1_blocks[i].p(changed, state, __chartFunctionsKeys, __chartFunctionsKeys[i], i);
						} else {
							each_1_blocks[i] = create_each_block_1(state, __chartFunctionsKeys, __chartFunctionsKeys[i], i, component);
							each_1_blocks[i].c();
							each_1_blocks[i].m(select_1, null);
						}
					}

					for (; i < each_1_blocks.length; i += 1) {
						each_1_blocks[i].u();
						each_1_blocks[i].d();
					}
					each_1_blocks.length = __chartFunctionsKeys.length;
				}

				if (!select_1_updating) selectOption(select_1, state.chartFunction);

				var sorting = state.__aggregateFunctions[state.aggregateFunction].sorting;

				if (changed.__aggregateFunctions || changed.aggregateFunction) {
					for (var i = 0; i < sorting.length; i += 1) {
						if (each_2_blocks[i]) {
							each_2_blocks[i].p(changed, state, sorting, sorting[i], i);
						} else {
							each_2_blocks[i] = create_each_block_2(state, sorting, sorting[i], i, component);
							each_2_blocks[i].c();
							each_2_blocks[i].m(select_2, null);
						}
					}

					for (; i < each_2_blocks.length; i += 1) {
						each_2_blocks[i].u();
						each_2_blocks[i].d();
					}
					each_2_blocks.length = sorting.length;
				}

				if (!select_2_updating) selectOption(select_2, state.sort);

				var queryeditor_changes = {};
				if (!queryeditor_updating.options && changed.options) {
					queryeditor_changes.options = state.options;
					queryeditor_updating.options = true;
				}
				if (!queryeditor_updating.selectors && changed.selectors) {
					queryeditor_changes.selectors = state.selectors;
					queryeditor_updating.selectors = true;
				}
				if (!queryeditor_updating.supportedClasses && changed.supportedClasses) {
					queryeditor_changes.supportedClasses = state.supportedClasses;
					queryeditor_updating.supportedClasses = true;
				}
				queryeditor._set(queryeditor_changes);
				queryeditor_updating = {};

				queryeditor_context.state = state;

				if (changed.__showQueryEditor && div_3_class_value !== (div_3_class_value = "mb-3 " + (state.__showQueryEditor ? '' : 'd-none'))) {
					div_3.className = div_3_class_value;
				}

				if (changed.__loading && div_5_class_value !== (div_5_class_value = "loader " + (state.__loading ? '' : 'd-none'))) {
					div_5.className = div_5_class_value;
				}

				if (changed.__currentChart && div_7_class_value !== (div_7_class_value = state.__currentChart && state.__currentChart.raw ? 'card' : 'hidden')) {
					div_7.className = div_7_class_value;
				}

				if (changed.__currentChart && div_10_class_value !== (div_10_class_value = state.__currentChart && state.__currentChart.svg ? 'chart-svg' : 'hidden')) {
					div_10.className = div_10_class_value;
				}

				if (changed.__currentChart && canvas_class_value !== (canvas_class_value = state.__currentChart && state.__currentChart.chart ? 'chart-canvas' : 'hidden')) {
					canvas.className = canvas_class_value;
				}

				if (changed.chartHeight) {
					setStyle(div_6, "height", "" + state.chartHeight + "px");
				}
			},

			u: function unmount() {
				detachNode(div);
				if_block.u();

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].u();
				}

				for (var i = 0; i < each_1_blocks.length; i += 1) {
					each_1_blocks[i].u();
				}

				for (var i = 0; i < each_2_blocks.length; i += 1) {
					each_2_blocks[i].u();
				}
			},

			d: function destroy() {
				if_block.d();
				removeListener(button, "click", click_handler);

				destroyEach(each_blocks);

				removeListener(select, "change", select_change_handler);
				removeListener(select, "change", change_handler);

				destroyEach(each_1_blocks);

				removeListener(select_1, "change", select_1_change_handler);

				destroyEach(each_2_blocks);

				removeListener(select_2, "change", select_2_change_handler);
				removeListener(button_1, "click", click_handler_1);
				removeListener(button_2, "click", click_handler_2);
				removeListener(button_3, "click", click_handler_3);
				queryeditor.destroy(false);
				if (component.refs.titleraw === div_8) component.refs.titleraw = null;
				if (component.refs.chartraw === pre) component.refs.chartraw = null;
				if (component.refs.titlesvg === h5) component.refs.titlesvg = null;
				if (component.refs.chartsvg === div_11) component.refs.chartsvg = null;
				if (component.refs.chartcanvas === canvas) component.refs.chartcanvas = null;
				if (component.refs.canvascontainer === div_6) component.refs.canvascontainer = null;
			}
		};
	}

	// (4:6) {{#if __showQueryEditor}}
	function create_if_block(state, component) {
		var text;

		return {
			c: function create() {
				text = createText("Hide");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	// (4:35) {{else}}
	function create_if_block_1(state, component) {
		var text;

		return {
			c: function create() {
				text = createText("Show");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			u: function unmount() {
				detachNode(text);
			},

			d: noop
		};
	}

	// (9:8) {{#each __aggregateFunctionsKeys as key}}
	function create_each_block(state, __aggregateFunctionsKeys_1, key, key_index, component) {
		var option,
		    text_value = state.__aggregateFunctions[key].name,
		    text,
		    option_value_value;

		return {
			c: function create() {
				option = createElement("option");
				text = createText(text_value);
				this.h();
			},

			h: function hydrate() {
				option.__value = option_value_value = key;
				option.value = option.__value;
			},

			m: function mount(target, anchor) {
				insertNode(option, target, anchor);
				appendNode(text, option);
			},

			p: function update(changed, state, __aggregateFunctionsKeys_1, key, key_index) {
				if ((changed.__aggregateFunctions || changed.__aggregateFunctionsKeys) && text_value !== (text_value = state.__aggregateFunctions[key].name)) {
					text.data = text_value;
				}

				if (changed.__aggregateFunctionsKeys && option_value_value !== (option_value_value = key)) {
					option.__value = option_value_value;
				}

				option.value = option.__value;
			},

			u: function unmount() {
				detachNode(option);
			},

			d: noop
		};
	}

	// (19:8) {{#each __chartFunctionsKeys as key}}
	function create_each_block_1(state, __chartFunctionsKeys, key_1, key_index_1, component) {
		var option,
		    text_value = state.__chartFunctions[key_1].name,
		    text,
		    option_value_value;

		return {
			c: function create() {
				option = createElement("option");
				text = createText(text_value);
				this.h();
			},

			h: function hydrate() {
				option.__value = option_value_value = key_1;
				option.value = option.__value;
			},

			m: function mount(target, anchor) {
				insertNode(option, target, anchor);
				appendNode(text, option);
			},

			p: function update(changed, state, __chartFunctionsKeys, key_1, key_index_1) {
				if ((changed.__chartFunctions || changed.__chartFunctionsKeys) && text_value !== (text_value = state.__chartFunctions[key_1].name)) {
					text.data = text_value;
				}

				if (changed.__chartFunctionsKeys && option_value_value !== (option_value_value = key_1)) {
					option.__value = option_value_value;
				}

				option.value = option.__value;
			},

			u: function unmount() {
				detachNode(option);
			},

			d: noop
		};
	}

	// (29:8) {{#each __aggregateFunctions[aggregateFunction].sorting as sortOption}}
	function create_each_block_2(state, sorting, sortOption, sortOption_index, component) {
		var option,
		    text_value = sortOption.charAt(0).toUpperCase() + sortOption.substr(1),
		    text,
		    option_value_value;

		return {
			c: function create() {
				option = createElement("option");
				text = createText(text_value);
				this.h();
			},

			h: function hydrate() {
				option.__value = option_value_value = sortOption;
				option.value = option.__value;
			},

			m: function mount(target, anchor) {
				insertNode(option, target, anchor);
				appendNode(text, option);
			},

			p: function update(changed, state, sorting, sortOption, sortOption_index) {
				if ((changed.__aggregateFunctions || changed.aggregateFunction) && text_value !== (text_value = sortOption.charAt(0).toUpperCase() + sortOption.substr(1))) {
					text.data = text_value;
				}

				if ((changed.__aggregateFunctions || changed.aggregateFunction) && option_value_value !== (option_value_value = sortOption)) {
					option.__value = option_value_value;
				}

				option.value = option.__value;
			},

			u: function unmount() {
				detachNode(option);
			},

			d: noop
		};
	}

	function select_block_type(state) {
		if (state.__showQueryEditor) return create_if_block;
		return create_if_block_1;
	}

	function LogalyzerApp(options) {
		init(this, options);
		this.refs = {};
		this._state = assign(data(), options.data);
		this._recompute({ options: 1, selectors: 1, aggregateFunction: 1, chartFunction: 1, sort: 1, chartHeight: 1 }, this._state);

		if (!document.getElementById("svelte-3106213277-style")) add_css();

		var _oncreate = oncreate.bind(this);

		if (!options.root) {
			this._oncreate = [_oncreate];
			this._beforecreate = [];
			this._aftercreate = [];
		} else {
			this.root._oncreate.push(_oncreate);
		}

		this._fragment = create_main_fragment(this._state, this);

		if (options.target) {
			this._fragment.c();
			this._fragment.m(options.target, options.anchor || null);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(LogalyzerApp.prototype, methods, {
		destroy: destroy,
		get: get,
		fire: fire,
		observe: observe,
		on: on,
		set: set,
		teardown: destroy,
		_set: _set,
		_mount: _mount,
		_unmount: _unmount
	});

	LogalyzerApp.prototype._recompute = function _recompute(changed, state) {
		if (changed.options) {
			if (differs(state.__aggregateFunctions, state.__aggregateFunctions = __aggregateFunctions(state.options))) changed.__aggregateFunctions = true;
			if (differs(state.__aggregateFunctionsKeys, state.__aggregateFunctionsKeys = __aggregateFunctionsKeys(state.options))) changed.__aggregateFunctionsKeys = true;
		}

		if (changed.options || changed.selectors) {
			if (differs(state.query, state.query = query(state.options, state.selectors))) changed.query = true;
		}

		if (changed.aggregateFunction || changed.chartFunction || changed.options || changed.selectors || changed.sort || changed.chartHeight) {
			if (differs(state.urlHashUpdate, state.urlHashUpdate = urlHashUpdate(state.aggregateFunction, state.chartFunction, state.options, state.selectors, state.sort, state.chartHeight))) changed.urlHashUpdate = true;
		}
	};

	function setAttribute(node, attribute, value) {
		node.setAttribute(attribute, value);
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function appendNode(node, target) {
		target.appendChild(node);
	}

	function selectValue(select) {
		var selectedOption = select.querySelector(':checked') || select.options[0];
		return selectedOption && selectedOption.__value;
	}

	function assign(target) {
		var k,
		    source,
		    i = 1,
		    len = arguments.length;
		for (; i < len; i++) {
			source = arguments[i];
			for (k in source) target[k] = source[k];
		}

		return target;
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function addListener(node, event, handler) {
		node.addEventListener(event, handler, false);
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function insertNode(node, target, anchor) {
		target.insertBefore(node, anchor);
	}

	function selectOption(select, value) {
		for (var i = 0; i < select.options.length; i += 1) {
			var option = select.options[i];

			if (option.__value === value) {
				option.selected = true;
				return;
			}
		}
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function removeListener(node, event, handler) {
		node.removeEventListener(event, handler, false);
	}

	function destroyEach(iterations) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d();
		}
	}

	function noop() {}

	function init(component, options) {
		component._observers = { pre: blankObject(), post: blankObject() };
		component._handlers = blankObject();
		component._bind = options._bind;

		component.options = options;
		component.root = options.root || component;
		component.store = component.root.store || options.store;
	}

	function callAll(fns) {
		while (fns && fns.length) fns.pop()();
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = this.get = noop;

		if (detach !== false) this._fragment.u();
		this._fragment.d();
		this._fragment = this._state = null;
	}

	function get(key) {
		return key ? this._state[key] : this._state;
	}

	function fire(eventName, data) {
		var handlers = eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			handlers[i].call(this, data);
		}
	}

	function observe(key, callback, options) {
		var group = options && options.defer ? this._observers.post : this._observers.pre;

		(group[key] || (group[key] = [])).push(callback);

		if (!options || options.init !== false) {
			callback.__calling = true;
			callback.call(this, this._state[key]);
			callback.__calling = false;
		}

		return {
			cancel: function cancel() {
				var index = group[key].indexOf(callback);
				if (~index) group[key].splice(index, 1);
			}
		};
	}

	function on(eventName, handler) {
		if (eventName === 'teardown') return this.on('destroy', handler);

		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function cancel() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		this.root._lock = true;
		callAll(this.root._beforecreate);
		callAll(this.root._oncreate);
		callAll(this.root._aftercreate);
		this.root._lock = false;
	}

	function _set(newState) {
		var oldState = this._state,
		    changed = {},
		    dirty = false;

		for (var key in newState) {
			if (differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign({}, oldState, newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			dispatchObservers(this, this._observers.pre, changed, this._state, oldState);
			this._fragment.p(changed, this._state);
			dispatchObservers(this, this._observers.post, changed, this._state, oldState);
		}
	}

	function _mount(target, anchor) {
		this._fragment.m(target, anchor);
	}

	function _unmount() {
		if (this._fragment) this._fragment.u();
	}

	function differs(a, b) {
		return a !== b || a && typeof a === 'object' || typeof a === 'function';
	}

	function blankObject() {
		return Object.create(null);
	}

	function dispatchObservers(component, group, changed, newState, oldState) {
		for (var key in group) {
			if (!changed[key]) continue;

			var newValue = newState[key];
			var oldValue = oldState[key];

			var callbacks = group[key];
			if (!callbacks) continue;

			for (var i = 0; i < callbacks.length; i += 1) {
				var callback = callbacks[i];
				if (callback.__calling) continue;

				callback.__calling = true;
				callback.call(component, newValue, oldValue);
				callback.__calling = false;
			}
		}
	}
	exports.default = LogalyzerApp;
});
